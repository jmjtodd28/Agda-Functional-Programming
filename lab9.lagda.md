# Week 9 - Lab Sheet

```agda
{-# OPTIONS --safe --without-K --auto-inline #-}

module lab9 where

open import prelude
open import decidability
open import Fin
open import List-functions
open import isomorphisms
open import sorting
open import strict-total-order

open import solutions.lab8
```

For all of the following questions we will work with a type `X` that
has decidable equality and a strict total order `_<_`.

```agda
module Part1
        {X : Type}
        (sto : StrictTotalOrder X)
       where

 open StrictTotalOrder sto
```

## Exercise 1

In the [lecture notes](../sorting.lagda.md) the type `Pos xs` was
introduced for every list `xs : List X`.

This is the type of positions in the list; for example, the type
`Pos (1 :: 2 :: [ 3 ])` has elements `inl ‚ãÜ`, `inr (inl ‚ãÜ)` and
`inr (inr (inl ‚ãÜ))`, representing the first, second and third elements
of the list, respectively.

Given any list `xs : List X`, there is a natural ordering of its
positions.

**Define** this strict total order.

```agda
 _<[Pos]_ : {X : Type} {xs : List X} ‚Üí Pos xs ‚Üí Pos xs ‚Üí Type
 _<[Pos]_ {X} {x :: xs} (inl ‚ãÜ) (inl ‚ãÜ) = ùüò
 _<[Pos]_ {X} {x :: xs} (inl ‚ãÜ) (inr q) = ùüô
 _<[Pos]_ {X} {x :: xs} (inr p) (inl ‚ãÜ) = ùüò
 _<[Pos]_ {X} {x :: xs} (inr p) (inr q) = p <[Pos] q
```

## Exercise 2

We give some facts about the type `Y ‚àî Z` for any types `Y` and `Z`:

 1. `inl y` does not equal `inr z` (for all `y : Y` and `z : Z`),
 1. `inr z` does not equal `inl y` (for all `y : Y` and `z : Z`),
 1. If `inl y‚ÇÅ ‚â° inl y‚ÇÇ` then `y‚ÇÅ ‚â° y‚ÇÇ` (for all `y‚ÇÅ,y‚ÇÇ : Y`),
 1. If `inr z‚ÇÅ ‚â° inr z‚ÇÇ` then `z‚ÇÅ ‚â° z‚ÇÇ` (for all `z‚ÇÅ,z‚ÇÇ : Z`).

```agda
 inl-is-not-inr : {Y Z : Type} {y : Y} {z : Z}
                ‚Üí ¬¨ (inl {Y} {Z} y ‚â° inr {Y} {Z} z)
 inl-is-not-inr ()

 inr-is-not-inl : {Y Z : Type} {y : Y} {z : Z}
                ‚Üí ¬¨ (inr {Y} {Z} z ‚â° inl {Y} {Z} y)
 inr-is-not-inl ()

 inl-lc : {Y Z : Type} {y‚ÇÅ y‚ÇÇ : Y}
        ‚Üí inl {Y} {Z} y‚ÇÅ ‚â° inl {Y} {Z} y‚ÇÇ ‚Üí y‚ÇÅ ‚â° y‚ÇÇ
 inl-lc (refl _) = refl _

 inr-lc : {Y Z : Type} {z‚ÇÅ z‚ÇÇ : Z}
        ‚Üí inr {Y} {Z} z‚ÇÅ ‚â° inr {Y} {Z} z‚ÇÇ ‚Üí z‚ÇÅ ‚â° z‚ÇÇ
 inr-lc (refl _) = refl _
```

Using the facts above, **prove** that if both `Y` and `Z` have
[decidable equality](../decidability.lagda.md), then so does `Y ‚àî Z`.

```agda
 +-has-decidable-equality : {Y Z : Type}
                          ‚Üí has-decidable-equality Y
                          ‚Üí has-decidable-equality Z
                          ‚Üí has-decidable-equality (Y ‚àî Z)
 +-has-decidable-equality p q (inl x) (inl y) = lemma (p x y)
   where
     lemma : (x ‚â° y) ‚àî ¬¨ (x ‚â° y)
           ‚Üí is-decidable (inl x ‚â° inl y)
     lemma (inl (refl .x)) = inl (refl (inl x))
     lemma (inr x) = inr Œª z ‚Üí x (inl-lc z)
 +-has-decidable-equality p q (inl x) (inr y) = inr Œª z ‚Üí inl-is-not-inr z 
 +-has-decidable-equality p q (inr x) (inl y) = inr Œª z ‚Üí inr-is-not-inl z
 +-has-decidable-equality p q (inr x) (inr y) = lemma (q x y)
   where
     lemma : (x ‚â° y) ‚àî ¬¨ (x ‚â° y)
           ‚Üí is-decidable (inr x ‚â° inr y)
     lemma (inl (refl .x)) = inl (refl (inr x))
     lemma (inr x) = inr Œª z ‚Üí x (inr-lc z)

```

## Exercise 3

`_<[Pos]_` defined in Exercise 1 must satisfy all the necessary
properties of a strict total order:
  * `Pos xs` has decidable equality,
  * `_<[Pos]_` is irreflexive,
  * `_<[Pos]_` is transitive,
  * `_<[Pos]_` is connected.

**Prove** that it does.

```agda

 ùüô-has-decidable-equality : has-decidable-equality ùüô
 ùüô-has-decidable-equality ‚ãÜ ‚ãÜ = inl (refl ‚ãÜ)
 
 <[Pos]-decidable : {xs : List X} ‚Üí has-decidable-equality (Pos xs)
 <[Pos]-decidable {x :: xs} p q = +-has-decidable-equality ùüô-has-decidable-equality <[Pos]-decidable p q

 <[Pos]-irreflexive : {xs : List X} ‚Üí (x : Pos xs) ‚Üí ¬¨ (x <[Pos] x)
 <[Pos]-irreflexive {x :: xs} (inr y) q = <[Pos]-irreflexive y q

 <[Pos]-transitive : {xs : List X} ‚Üí {n m o : Pos xs}
                   ‚Üí n <[Pos] m ‚Üí m <[Pos] o ‚Üí n <[Pos] o
 <[Pos]-transitive {x :: xs} {inl n} {inr m} {inr o} p q = p
 <[Pos]-transitive {x :: xs} {inr n} {inr m} {inr o} p q = <[Pos]-transitive {xs} p q

 
 <[Pos]-connected : {xs : List X} ‚Üí {n m : Pos xs}
                  ‚Üí ¬¨ (n ‚â° m) ‚Üí (n <[Pos] m) ‚àî (m <[Pos] n)
 <[Pos]-connected {x :: xs} {inl ‚ãÜ} {inl ‚ãÜ} q = inl (q (refl (inl ‚ãÜ)))
 <[Pos]-connected {x :: xs} {inl n} {inr m} q = inl n
 <[Pos]-connected {x :: xs} {inr n} {inl m} q = inr m
 <[Pos]-connected {x :: xs} {inr n} {inr m} q = lemma (<[Pos]-decidable n m)
   where
     lemma : (n ‚â° m) ‚àî (n ‚â° m ‚Üí ùüò)
           ‚Üí (n <[Pos] m) ‚àî (m <[Pos] n)
     lemma (inl (refl .n)) = ùüò-elim (q (refl (inr n)))
     lemma (inr z) = <[Pos]-connected z

 STO : (xs : List X) ‚Üí StrictTotalOrder (Pos xs)
 STO xs = record
           { _<_ = _<[Pos]_
           ; irreflexive = <[Pos]-irreflexive
           ; transitive = Œª {n} {m} {o} ‚Üí <[Pos]-transitive {xs} {n} {m} {o}
           ; connected = <[Pos]-connected
           ; ‚â°-is-decidable = <[Pos]-decidable {xs}
           } 
```

## Exercise 4

As you saw in [last week's lab sheet](../solutions/lab8.lagda.md),
every strict total order `_<_` has an associated non-strict total
order `_‚â§_`, defined `x ‚â§ y = (y ‚â° x) ‚àî (x < y)`.

We use this fact to extract `_‚â§_` on `X` and `_‚â§[Pos}_` on `Pos xs`
given any list `xs : List X`.

```agda
module _
        {X : Type}
        (sto : StrictTotalOrder X)
       where

 open StrictTotalOrder sto hiding(_‚â§_)
 open Part1 sto

 nsto : NonStrictTotalOrder X
 nsto = non-strict-total-order-from-strict-total-order sto

 NSTO : (xs : List X) ‚Üí NonStrictTotalOrder (Pos xs)
 NSTO xs = non-strict-total-order-from-strict-total-order (STO xs)

 _‚â§_ : X ‚Üí X ‚Üí Type
 _‚â§_ = NonStrictTotalOrder._‚â§_ nsto

 _‚â§[Pos]_ : {xs : List X} ‚Üí Pos xs ‚Üí Pos xs ‚Üí Type
 _‚â§[Pos]_ {xs} = NonStrictTotalOrder._‚â§_ (NSTO xs)

 ‚â§-reflexive : (x : X) ‚Üí x ‚â§ x
 ‚â§-reflexive = NonStrictTotalOrder.reflexive nsto

 ‚â§-transitive : {x y z : X} ‚Üí x ‚â§ y ‚Üí y ‚â§ z ‚Üí x ‚â§ z
 ‚â§-transitive = NonStrictTotalOrder.transitive nsto
```

Given any types `X` and `Y` equipped with non-strict total orders
`_‚â§X_` and `_‚â§Y_` respectively, we define the notion of a *monotonic
function*.

A function `f : X ‚Üí Y` is monotonic if as the arguments increase (or
stay the same), the value of the function at the argument also
increases (or stays the same).

```agda
 monotonic : {X Y : Type}
           ‚Üí NonStrictTotalOrder X ‚Üí NonStrictTotalOrder Y
           ‚Üí (f : X ‚Üí Y) ‚Üí Type
 monotonic {X} {Y} nstox nstoy f = (x y : X) ‚Üí x ‚â§X y ‚Üí f x ‚â§Y f y
   where
     _‚â§X_ = NonStrictTotalOrder._‚â§_ nstox
     _‚â§Y_ = NonStrictTotalOrder._‚â§_ nstoy
```

The `Inhab : Pos xs ‚Üí X` function
[from the lecture notes](../sorting.lagda.md) is a monotonic function
when `xs` is a Sorted list: i.e., as the position argument increases
(or stays the same), the inhabitant obtained from the list also
increases (or stays the same).

To state this mathematically, we want to prove that if `n ‚â§[Pos] m`
then `Inhab xs n ‚â§ Inhab xs m`.

First we will prove two small lemmas.

### Exercise 4.1

**Prove** that if a list `(x :: xs)` is sorted, then the list `xs` is
also sorted.

```agda
 tail-sorted : (x : X) (xs : List X)
             ‚Üí Sorted sto (x :: xs)
             ‚Üí Sorted sto       xs            
 tail-sorted x .[] sing-sorted = nil-sorted
 tail-sorted x .(_ :: _) (adj-sorted p y) = p
```

### Exercise 4.2

**Prove** that if a list `(x :: y :: xs)` is sorted, then the list
`(x :: xs)` is also sorted.

```agda
 drop-one-sorted : (x y : X) (xs : List X)
                 ‚Üí Sorted sto (x :: y :: xs)
                 ‚Üí Sorted sto (x      :: xs)
 drop-one-sorted x y .[] (adj-sorted sing-sorted x‚ÇÅ) = sing-sorted
 drop-one-sorted x y .(y :: _) (adj-sorted (adj-sorted p (inl (refl .y))) b) = adj-sorted p b
 drop-one-sorted x .x .(_ :: _) (adj-sorted (adj-sorted p (inr a)) (inl (refl .x))) = adj-sorted p (inr a)
 drop-one-sorted x y .(_ :: _) (adj-sorted (adj-sorted p (inr a)) (inr b)) = adj-sorted p (inr (transitive b a))
```

### Exercise 4.3

**Prove** that, given a sorted list `xs`, `Inhab xs` is monotonic.

```agda
 Inhab-monotonic : (xs : List X) ‚Üí Sorted sto xs
                   ‚Üí monotonic (NSTO xs) nsto (Inhab xs)                   
 Inhab-monotonic (x :: []) sxs y z p = {!!}
 Inhab-monotonic (x :: y :: xs) sxs a b p = {!!}
 
```

## Exercise 5

Recall the alternate definition of sorted list given in the lecture:

```agda

 open _‚âÖ_
 open import iso-utils

 data SortedList : Type
 prependable : X ‚Üí SortedList ‚Üí Type

 data SortedList where
   nil : SortedList
   cons : (x : X) (xs : SortedList)
     ‚Üí prependable x xs ‚Üí SortedList

 prependable x‚ÇÄ nil = ùüô
 prependable x‚ÇÄ (cons x xs _) = x‚ÇÄ ‚â§ x

 Pos‚Çõ : SortedList ‚Üí Type
 Pos‚Çõ nil = ùüò
 Pos‚Çõ (cons _ xs _) = ùüô ‚àî Pos‚Çõ xs

 _!!‚Çõ_ : (xs : SortedList) ‚Üí Pos‚Çõ xs ‚Üí X
 cons x xs œÅ !!‚Çõ inl ‚ãÜ = x
 cons x xs œÅ !!‚Çõ inr p = xs !!‚Çõ p

``` 

### Exercise 5.1

In order to better understand the presentation of insertion sort using
this definition, **redo** the definitions from the lecture:

```agda

 insert : X ‚Üí SortedList ‚Üí SortedList
 insert-lem : (x‚ÇÄ x : X) (xs : SortedList)
   ‚Üí (œÅ : prependable x xs)
   ‚Üí x < x‚ÇÄ
   ‚Üí prependable x (insert x‚ÇÄ xs)

 insert x‚ÇÄ nil = cons x‚ÇÄ nil ‚ãÜ
 insert x‚ÇÄ (cons x xs p) with trichotomy x‚ÇÄ x
 ... | inl x‚ÇÄ<x = cons x‚ÇÄ (cons x xs p) (inr x‚ÇÄ<x)
 ... | inr (inl x‚ÇÄ‚â°x) = cons x‚ÇÄ (cons x xs p) (inl (sym x‚ÇÄ‚â°x))
 ... | inr (inr x‚ÇÄ>x) = cons x (insert x‚ÇÄ xs) (insert-lem x‚ÇÄ x xs p x‚ÇÄ>x)
 
 
 insert-lem x‚ÇÄ x nil œÅ x<x‚ÇÄ = inr x<x‚ÇÄ
 insert-lem x‚ÇÄ x (cons y xs œÉ) œÅ x‚ÇÄ<x with trichotomy x‚ÇÄ y
 ... | inl x‚ÇÄ<y = inr x‚ÇÄ<x
 ... | inr (inl x‚ÇÄ‚â°y) = inr x‚ÇÄ<x
 ... | inr (inr x‚ÇÄ>y) = œÅ
 
 insert-all : List X ‚Üí SortedList ‚Üí SortedList
 insert-all [] ys = ys
 insert-all (x :: xs) ys = insert x (insert-all xs ys)

 insertion-sort : List X ‚Üí SortedList
 insertion-sort xs = insert-all xs nil 

```
 
### Exercise 5.2

Now prove the compatibilites between insertion and positions:

```agda
 insert-pos-lem : (x : X) (xs : SortedList)
   ‚Üí ùüô ‚àî Pos‚Çõ xs ‚âÖ Pos‚Çõ (insert x xs) 
 insert-pos-lem x nil = id-iso (ùüô ‚àî ùüò)
 insert-pos-lem x‚ÇÄ (cons x xs p) with trichotomy x‚ÇÄ x
 ... | inl x‚ÇÄ<x = id-iso _
 ... | inr (inl x‚ÇÄ‚â°x) = id-iso _
 ... | inr (inr x‚ÇÄ>x) = 
   ùüô ‚àî ùüô ‚àî Pos‚Çõ xs ‚âÖ‚ü® ‚àî-left-swap-iso ùüô ùüô (Pos‚Çõ xs) ‚ü©
   ùüô ‚àî ùüô ‚àî Pos‚Çõ xs ‚âÖ‚ü® ‚àî-pair-iso (id-iso ùüô) (insert-pos-lem x‚ÇÄ xs) ‚ü©
   ùüô ‚àî Pos‚Çõ (insert x‚ÇÄ xs)            ‚àé·µ¢

 insert-pos-lem-left : (x : X) (xs : SortedList)
   ‚Üí x ‚â° insert x xs !!‚Çõ bijection (insert-pos-lem x xs) (inl ‚ãÜ) 
 insert-pos-lem-left x nil = refl x
 insert-pos-lem-left x‚ÇÄ (cons x xs p) with trichotomy x‚ÇÄ x
 ... | inl x‚ÇÄ<x = refl _
 ... | inr (inl x‚ÇÄ‚â°x) = refl _
 ... | inr (inr x‚ÇÄ>x) = insert-pos-lem-left x‚ÇÄ xs

 insert-pos-lem-right : (x : X) (xs : SortedList) (p : Pos‚Çõ xs)
   ‚Üí xs !!‚Çõ p ‚â° (insert x xs !!‚Çõ bijection (insert-pos-lem x xs) (inr p) )
 insert-pos-lem-right x‚ÇÄ (cons x xs œÉ) (inl p) with trichotomy x‚ÇÄ x
 ... | inl x‚ÇÄ<x = refl x
 ... | inr (inl x‚ÇÄ‚â°x) = refl _
 ... | inr (inr x‚ÇÄ>x) = refl x
 insert-pos-lem-right x‚ÇÄ (cons x xs œÉ) (inr p) with trichotomy x‚ÇÄ x
 ... | inl x‚ÇÄ<x = refl _
 ... | inr (inl x‚ÇÄ‚â°x) = refl _
 ... | inr (inr x‚ÇÄ>x) = insert-pos-lem-right x‚ÇÄ xs p 

 insertion-pos-iso : (xs : List X) ‚Üí Pos xs ‚âÖ Pos‚Çõ (insertion-sort xs)
 insertion-pos-iso [] = id-iso _
 insertion-pos-iso (x :: xs) =
   ùüô ‚àî Pos xs                      ‚âÖ‚ü® ‚àî-pair-iso (id-iso ùüô) (insertion-pos-iso xs) ‚ü©
   ùüô ‚àî Pos‚Çõ (insertion-sort xs)    ‚âÖ‚ü® insert-pos-lem x (insertion-sort xs) ‚ü©
   Pos‚Çõ (insertion-sort (x :: xs)) ‚àé·µ¢
```

### Exercise 5.3

Finally, prove that the isomorphism constructred above respects inhabitants:

```agda
 _!!_ : (xs : List X) ‚Üí Pos xs ‚Üí X
 xs !! p = Inhab xs p

 insertion-inhab : (xs : List X) (p : Pos xs)
   ‚Üí xs !! p ‚â° (insertion-sort xs !!‚Çõ bijection (insertion-pos-iso xs) p)
 insertion-inhab (x :: xs) (inl ‚ãÜ) =
   x ‚â°‚ü® insert-pos-lem-left x (insertion-sort xs) ‚ü©
     (insert x (insert-all xs nil) !!‚Çõ bijection (insert-pos-lem x (insert-all xs nil)) (inl ‚ãÜ)) ‚àé
 insertion-inhab (x :: xs) (inr p) =
   ((x :: xs) !! inr p)
       ‚â°‚ü® insertion-inhab xs p  ‚ü©
   (insertion-sort xs !!‚Çõ bijection (insertion-pos-iso xs) p)
       ‚â°‚ü® insert-pos-lem-right x (insertion-sort xs) (bijection (insertion-pos-iso xs) p)  ‚ü©
   (insertion-sort (x :: xs) !!‚Çõ
    bijection (insertion-pos-iso (x :: xs)) (inr p)) ‚àé
```

